#!/usr/bin/env python3
"""
Exploit Detector - Détection des vulnérabilités DMARC RUA/RUF
Basé sur la recherche USENIX Security 2023 sur les abus DMARC

Vulnérabilités détectées:
1. External Reporting (absence de validation externe)
2. Report Data Exfiltration (rapports vers domaines tiers)
3. Amplification Attack potential
4. Forensic Report Abuse (RUF sensibles)
5. Policy Bypass (p=none avec reporting)
"""

from typing import Dict, List
from dmarc_analyzer import get_organizational_domain


class ExploitDetector:
    """Détecte les vulnérabilités potentielles dans les configurations DMARC."""
    
    @staticmethod
    def detect_external_reporting(domain: str, rua_domains: List[str], ruf_domains: List[str]) -> Dict:
        """
        EXPLOIT 1: External Reporting sans validation
        
        Détecte si les rapports DMARC sont envoyés à des domaines externes
        sans validation appropriée (RFC 7489 Section 7.1).
        
        Risque: Un attaquant peut recevoir des rapports sur un domaine qu'il ne contrôle pas.
        """
        org_domain = get_organizational_domain(domain)
        external_rua = []
        external_ruf = []
        
        for rua_domain in rua_domains:
            if rua_domain and get_organizational_domain(rua_domain) != org_domain:
                external_rua.append(rua_domain)
        
        for ruf_domain in ruf_domains:
            if ruf_domain and get_organizational_domain(ruf_domain) != org_domain:
                external_ruf.append(ruf_domain)
        
        vulnerable = bool(external_rua or external_ruf)
        
        return {
            'name': 'EXTERNAL_REPORTING',
            'vulnerable': vulnerable,
            'severity': 'HIGH' if external_ruf else 'MEDIUM',
            'description': 'Rapports DMARC envoyés à des domaines externes sans validation',
            'external_rua': external_rua,
            'external_ruf': external_ruf,
            'details': (
                f"Domaines externes détectés: RUA={external_rua}, RUF={external_ruf}. "
                "Un attaquant pourrait exploiter cela pour recevoir des données sensibles."
            ) if vulnerable else None
        }
    
    @staticmethod
    def detect_data_exfiltration(rua_domains: List[str], ruf_domains: List[str]) -> Dict:
        """
        EXPLOIT 2: Data Exfiltration via Report URIs
        
        Détecte les configurations qui envoient des rapports à plusieurs destinations,
        augmentant le risque d'exfiltration de données.
        
        Risque: Les rapports forensiques (RUF) contiennent des informations sensibles
        (headers d'emails, IPs, etc.)
        """
        multiple_rua = len(rua_domains) > 1
        multiple_ruf = len(ruf_domains) > 1
        has_ruf = len(ruf_domains) > 0
        
        vulnerable = multiple_rua or multiple_ruf or has_ruf
        
        risk_factors = []
        if multiple_rua:
            risk_factors.append(f"{len(rua_domains)} destinations RUA")
        if multiple_ruf:
            risk_factors.append(f"{len(ruf_domains)} destinations RUF")
        if has_ruf:
            risk_factors.append("Rapports forensiques activés (données sensibles)")
        
        return {
            'name': 'DATA_EXFILTRATION',
            'vulnerable': vulnerable,
            'severity': 'HIGH' if has_ruf else 'MEDIUM',
            'description': 'Risque d\'exfiltration de données via rapports multiples',
            'rua_count': len(rua_domains),
            'ruf_count': len(ruf_domains),
            'details': f"Facteurs de risque: {', '.join(risk_factors)}" if vulnerable else None
        }
    
    @staticmethod
    def detect_amplification_potential(policy: str, rua_uris: List[str], ruf_uris: List[str]) -> Dict:
        """
        EXPLOIT 3: Amplification Attack Potential
        
        Détecte si la configuration DMARC peut être utilisée pour des attaques
        par amplification (envoi massif de rapports).
        
        Risque: Un attaquant peut usurper des emails pour générer des rapports
        volumineux vers une cible.
        """
        # Politique permissive (none) + rapports = potentiel d'amplification
        permissive_policy = policy in ['none', None]
        has_reporting = bool(rua_uris or ruf_uris)
        
        vulnerable = permissive_policy and has_reporting
        
        amplification_factor = 0
        if vulnerable:
            # Facteur d'amplification estimé
            amplification_factor = len(rua_uris) + (len(ruf_uris) * 10)  # RUF plus volumineux
        
        return {
            'name': 'AMPLIFICATION_ATTACK',
            'vulnerable': vulnerable,
            'severity': 'MEDIUM',
            'description': 'Configuration permettant des attaques par amplification',
            'policy': policy,
            'amplification_factor': amplification_factor,
            'details': (
                f"Politique permissive ({policy}) avec {len(rua_uris)} RUA et {len(ruf_uris)} RUF. "
                f"Facteur d'amplification estimé: {amplification_factor}x"
            ) if vulnerable else None
        }
    
    @staticmethod
    def detect_forensic_abuse(ruf_uris: List[str], policy: str) -> Dict:
        """
        EXPLOIT 4: Forensic Report Abuse
        
        Les rapports forensiques (RUF) contiennent des informations très sensibles:
        - En-têtes complets des emails
        - Adresses IP des expéditeurs
        - Contenu potentiel des messages
        
        Risque: Utilisation abusive pour collecter des informations sensibles.
        """
        has_ruf = bool(ruf_uris)
        permissive = policy in ['none', None]
        
        vulnerable = has_ruf
        severity = 'CRITICAL' if (has_ruf and permissive) else 'HIGH' if has_ruf else 'LOW'
        
        return {
            'name': 'FORENSIC_REPORT_ABUSE',
            'vulnerable': vulnerable,
            'severity': severity,
            'description': 'Rapports forensiques activés (données sensibles exposées)',
            'ruf_count': len(ruf_uris),
            'ruf_uris': ruf_uris,
            'details': (
                f"{len(ruf_uris)} destination(s) RUF configurée(s). "
                "Les rapports forensiques contiennent des en-têtes complets et des IPs. "
                f"Politique: {policy}"
            ) if vulnerable else None
        }
    
    @staticmethod
    def detect_policy_bypass(policy: str, subdomain_policy: str, pct: int) -> Dict:
        """
        EXPLOIT 5: Policy Bypass Opportunities
        
        Détecte les configurations DMARC faibles qui peuvent être contournées.
        
        Risques:
        - Politique none: pas d'application
        - pct < 100: seulement un pourcentage des emails est vérifié
        - sp différent de p: sous-domaines moins protégés
        """
        weak_policy = policy in ['none', None]
        partial_enforcement = pct < 100
        subdomain_weaker = (
            subdomain_policy in ['none', None] and 
            policy in ['quarantine', 'reject']
        )
        
        vulnerable = weak_policy or partial_enforcement or subdomain_weaker
        
        issues = []
        if weak_policy:
            issues.append(f"Politique faible: {policy}")
        if partial_enforcement:
            issues.append(f"Application partielle: {pct}%")
        if subdomain_weaker:
            issues.append(f"Sous-domaines moins protégés: sp={subdomain_policy}")
        
        severity = 'HIGH' if weak_policy else 'MEDIUM'
        
        return {
            'name': 'POLICY_BYPASS',
            'vulnerable': vulnerable,
            'severity': severity,
            'description': 'Configuration DMARC faible permettant des contournements',
            'policy': policy,
            'subdomain_policy': subdomain_policy,
            'pct': pct,
            'details': f"Problèmes détectés: {', '.join(issues)}" if vulnerable else None
        }
    
    @staticmethod
    def detect_uri_manipulation(rua_uris: List[str], ruf_uris: List[str]) -> Dict:
        """
        EXPLOIT 6: URI Manipulation and Injection
        
        Détecte des URIs potentiellement malformées ou suspectes qui pourraient
        être utilisées pour des injections ou des redirections.
        """
        suspicious_uris = []
        
        all_uris = rua_uris + ruf_uris
        for uri in all_uris:
            # Vérifier les URIs suspectes
            if not uri.startswith(('mailto:', 'http://', 'https://')):
                suspicious_uris.append(uri)
            # URIs avec des paramètres étranges
            elif '!' in uri and uri.count('!') > 1:
                suspicious_uris.append(uri)
            # URIs avec des caractères encodés suspects
            elif '%' in uri or '<' in uri or '>' in uri:
                suspicious_uris.append(uri)
        
        vulnerable = bool(suspicious_uris)
        
        return {
            'name': 'URI_MANIPULATION',
            'vulnerable': vulnerable,
            'severity': 'MEDIUM',
            'description': 'URIs suspectes ou malformées détectées',
            'suspicious_uris': suspicious_uris,
            'details': f"URIs suspectes: {suspicious_uris}" if vulnerable else None
        }
    
    @classmethod
    def run_all_detectors(cls, analysis_result: Dict) -> Dict:
        """
        Execute tous les détecteurs d'exploits sur un résultat d'analyse DMARC.
        
        Args:
            analysis_result: Résultat de analyze_dmarc_security()
        
        Returns:
            Dictionnaire avec tous les exploits détectés et un score de risque
        """
        domain = analysis_result['domain']
        policy = analysis_result.get('policy', 'none')
        subdomain_policy = analysis_result.get('subdomain_policy', policy)
        pct = analysis_result.get('pct', 100)
        rua_uris = analysis_result.get('rua_uris', [])
        ruf_uris = analysis_result.get('ruf_uris', [])
        rua_domains = analysis_result.get('rua_domains', [])
        ruf_domains = analysis_result.get('ruf_domains', [])
        
        # Exécuter tous les détecteurs
        exploits = {
            'external_reporting': cls.detect_external_reporting(domain, rua_domains, ruf_domains),
            'data_exfiltration': cls.detect_data_exfiltration(rua_domains, ruf_domains),
            'amplification': cls.detect_amplification_potential(policy, rua_uris, ruf_uris),
            'forensic_abuse': cls.detect_forensic_abuse(ruf_uris, policy),
            'policy_bypass': cls.detect_policy_bypass(policy, subdomain_policy, pct),
            'uri_manipulation': cls.detect_uri_manipulation(rua_uris, ruf_uris)
        }
        
        # Calculer le score de risque global
        risk_score = cls.calculate_risk_score(exploits)
        
        # Compter les vulnérabilités
        vulnerabilities = [name for name, exploit in exploits.items() if exploit['vulnerable']]
        
        return {
            'domain': domain,
            'exploits': exploits,
            'vulnerabilities': vulnerabilities,
            'vulnerability_count': len(vulnerabilities),
            'risk_score': risk_score,
            'risk_level': cls.get_risk_level(risk_score)
        }
    
    @staticmethod
    def calculate_risk_score(exploits: Dict) -> int:
        """
        Calcule un score de risque global (0-100) basé sur les exploits détectés.
        """
        severity_weights = {
            'CRITICAL': 30,
            'HIGH': 20,
            'MEDIUM': 10,
            'LOW': 5
        }
        
        score = 0
        for exploit in exploits.values():
            if exploit['vulnerable']:
                severity = exploit['severity']
                score += severity_weights.get(severity, 5)
        
        return min(100, score)
    
    @staticmethod
    def get_risk_level(risk_score: int) -> str:
        """Convertit un score de risque en niveau."""
        if risk_score >= 75:
            return 'CRITICAL'
        elif risk_score >= 50:
            return 'HIGH'
        elif risk_score >= 25:
            return 'MEDIUM'
        else:
            return 'LOW'


if __name__ == '__main__':
    # Test avec un exemple
    from dmarc_analyzer import analyze_dmarc_security
    
    test_domain = 'example.com'
    print(f"=== Détection d'exploits pour {test_domain} ===\n")
    
    analysis = analyze_dmarc_security(test_domain)
    exploits = ExploitDetector.run_all_detectors(analysis)
    
    print(f"Niveau de risque: {exploits['risk_level']} (score: {exploits['risk_score']}/100)")
    print(f"Vulnérabilités détectées: {exploits['vulnerability_count']}")
    
    for vuln_name in exploits['vulnerabilities']:
        exploit = exploits['exploits'][vuln_name]
        print(f"\n[{exploit['severity']}] {exploit['name']}")
        print(f"  {exploit['description']}")
        if exploit['details']:
            print(f"  Détails: {exploit['details']}")
